**IPC (Inter Process Communication) : 프로세스 간 통신**

---

[리눅스 커널 구조]

---

Process는 완전히 독립된 실행객체

⇒ 서로 독립되어 있다는 것은 다른 프로세스의 영향을 받지 않는다는 것을 의미한다.

⇒ 별도의 설비가 없이는 서로 간 통신이 어렵다.

⇒ 그래서, 커널이 제공하는게 IPC라는 내부 프로세스간 통신이다!

⇒ 프로세스는 커널이 제공하는 IPC 설비를 이용해서 프로세스간 통신을 할 수 있게 된다.

---

**IPC의 2가지 표준**

1. System V IPC
    1. 개발한지 비교적 오래된 버전
    2. 코드 호환성 보장 but API가 오래되어서 함수명이 명확하지 않다.
2. POSIX IPC
    1. 최근에 개발된 버전
    2. 직관적인 API ⇒ 사용하기 간편하다.

---

IPC 설비

1. PIPE (익명 PIPE, Anonymous PIPE)
    1. 파이프는 두 개의 프로세스를 연결한다.
    2. 하나는 데이터를 쓰기만, 하나는 읽기만 할 수 있다.
    3. Half-Duplex(반이중) 통신이라고도 한다.
    4. 송/수신을 둘 다 원한다면 파이프를 두 개 생성해야 한다.
2. Named PIPE(FIFO)
    1. 통신을 할 프로세스가 명확하게 알 수 있는 경우 사용
    2. 익명 파이프는 자식과 부모 관계 같이 서로 아는 사이에서만 통신을 할 수 있지만,
    Named 파이프의 경우 전혀 모르는 프로세스들 사이에서도 통신을 할 수 있다.
    3. FIFO도 PIPE의 일종이기에 반이중 통신을 지원한다.
3. Message Queue
    1. 큐는 선입선출의 자료구조를 가지는 통신 설비로 커널에서 관리
    2. Named PIPE가 데이터의 흐름이라면 message queue는 메모리 공간이다.
    3. message queue에 쓸 데이터에 번호를 붙여 여러 개의 프로세스가 동시에 데이터를 쉽게 다룰 수 있다.
4. Shared Memory(공유 메모리)
    1. 데이터를 아예 공유, 즉 함께 사용한다.
    2. 지금까지 공부한 설비는 모두 통신을 이용한 설비라면, shared memory는 공유메모리가 데이터 자체를 공유하도록 지원하는 설비이다.
    3. 중개자 없이 곧바로 메모리에 접근할 수 있기에 IPC 중에 가장 빠르게 작동한다.
5. Memory Map
    1. shared memeory처럼 메모리를 공유 but 열린파일을 메모리에 맵핑시켜서 공유한다.
6. socket
    1. 서버 : bind, listen, accept 등 소켓 연결을 위한 준비
    2. 클라 : connect → send를 통해 데이터를 주고받는다. close를 반드시 해야함