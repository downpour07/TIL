# Stack & Heap

### 1. 스택의 대표적인 특정에 대해 알려주세요.

> Stack은 후입선출 자료구조
마지막에 들어간 데이터가 먼저 나옴
> 

### 2. 스택에 데이터를 삽입하는 작업의 명칭과, 시간 복잡도를 알려주세요.

> Stack에 데이터를 삽입하는 작업은 PUSH이고,
PUSH의 시간 복잡도는 O(1)이다.
> 

### 3. 스택에서 데이터를 꺼내는 작업의 명칭과, 시간 복잡도를 알려주세요.

> Stack에서 데이터를 꺼내는 작업은 POP이고,
POP의 시간 복잡도는 O(1)이다.
> 

### 4. 스택은 어떤 경우에 사용 되나요?

> 인터넷 방문 기록 저장에 사용
뒤로가기시 마지막에 방문한 페이지가 먼저 나옴
> 

### 5. heap에 대해 알려주세요.

> heap은 완전 이진 트리형 자료구조
heap은 우선 순위 큐를 구현하기 위해 사용
> 

### 6. heap의 두 가지 종류에 대해 알려주세요.

> heap은 max heap과 min heap이 있다
max heap은 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리
min heap은 부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리
> 

### 7. 메모리 영역의 heap과 자료구조 heap의 차이는 무엇인가요?

> 메모리 영역의 heap과 자료구조의 heap은 서로 다른 개념이다
동음이의어라고 간주해도 무관하다
> 

### 8. heap을 구현하는 표준적인 자료구조는?

> heap을 구현하는 표준적인 자료구조는 배열이다
> 

### 9. 일반적으로 heap은 배열로 구현합니다. 이유는 무엇인가요?

> heap을 배열로 구현하는 이유는 인덱스 계산이 간결하고 접근과 탐색이 빠르기 때문입니다
> 

### 10. heap의 인덱스 계산이 간결한 이유는 무엇인가요?

> heap의 인덱스 계산이 간결한 이유는 배열로 힙을 구현할 때
각 노드의 인덱스와 부모/자식 노드의 인덱스 간에
간단한 수식 관계가 성립하기 때문입니다
> 

### 11. heap에서 A노드의 부모 인덱스를 구현하려면 어떻게 하나요?

> heap에서 A노드의 부모 인덱스는,
A노드의 인덱스를 2로 나눈 몫입니다
> 

### 12. 그럼 A노드의 왼쪽 자식 노드의 인덱스는 무엇인가요?

> heap에서 A노드의 왼쪽 자식노드의 인덱스는
{A노드 인덱스} X 2 입니다
> 

### 13. 그럼 A노드의 오른쪽 자식 노드의 인덱스는 무엇인가요?

> heap에서 A노드의 왼쪽 자식노드의 인덱스에 1을 더하면 됩니다
{A노드 인덱스} X 2 + 1 입니다
> 

### 14. heap에서 간편한 부모, 자식 인덱스 계산을 위해 필요한 조건은 무엇인가요?

> 첫째, heap이 완전 이진 트리 구조를 가져야 한다
둘째, heap의 인덱스를 1부터 시작해야 한다
> 

### 15. heap에서 인덱스를 1부터 시작해야 하는 이유는 무엇인가요?

> heap에서 인덱스를 1부터 시작해야
부모, 자식 노드의 인덱스 계산이 단순해진다
> 

### 16. heap에서 삽입 작업은 어떻게 이루어지나요?

> heap에서 삽입 작업은
첫째, 삽입할 요소를 heap의 마지막 위치에 추가
둘째, 부모 노드가 삽입된 노드보다 우선 순위가 낮다면 두 노드의 위치를 교환하는 작업을 반복한다
> 

### 17. heap에서 삽입 작업의 최선 경우는 어떤 경우이면 시간 복잡도는 어떻게 되나요?

> heap에서 삽입 작업의 최선 경우는 바닥부터 루트까지
경로를 수정할 필요가 없는 경우입니다
heap에서 삽입 작업의 최선 경우에 시간 복잡도는 O(log n)입니다
> 

### 18. heap에서 삽입 작업의 최악 경우는 어떤 경우이면 시간 복잡도는 어떻게 되나요?

> heap에서 삽입 작업의 최악 경우는 새로운 요소가
루트까지 올라가야 하는 경우입니다
heap에서 삽입 작업의 최악 경우에 시간 복잡도는 O(log n)으로
최선 경우와 같습니다
> 

### 19. heap에서 삽입 작업의 최선 경우와 최악 경우의 시간 복잡도가 O(log n)으로 같은 것은 어떤 의미를 내포하나요?

> heap의 삽입 작업에서 최선과 최악 경우에 시간 복잡도가 같다는 것은 크기에 비례하여 효율적으로 동작한다는 것을 의미합니다
> 

### 20. heap에서 삭제 연산의 동작은 어떻게 이루어지나요?

> heap에서 삭제 연산은
첫째, 루트 노드를 제거하고 heap의 마지막 요소를 루트로 이동시킨 뒤 두 자식 노드와 루트 자신을 비교합니다
둘째, 자식 노드가 자신보다 우선 순위가 높다면 자식 노드와 위치를 교환합니다
> 

### 21. heap의 삭제 연산의 시간 복잡도는 어떻게 되나요?

> heap의 삭제 연산의 시간 복잡도는 최선, 최악 모두 O(log n)입니다
>