## 컴퓨터 구조

### 1강 - 컴퓨터 구조를 알아야 하는 이유

<aside>
📖 **컴퓨터 구조를 알아야 하는 이유**

1. 문제 해결 능력
    
    ⇒ 문법에 맞는 소스 코드를 컴퓨터에 입력만 하는 개발자를 넘어 컴퓨터를 내려다보며 문제를 해결할 수 있는 개발자
    
2. 성능, 용량, 비용을 고려한 프로그래밍
    
    ⇒ 프로그래밍 언어의 문법만으로는 해결하기 어려운 문제
    
</aside>

### 2강 - 컴퓨터 구조의 큰 그림

<aside>
📖 **컴퓨터 구조의 큰 그림**

1. 컴퓨터가 이해하는 정보
    1. **데이터**
        
        : 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
        
        : 컴퓨터와 주고받는, 내부에 저장된 정보
        
        : 0과 1로 문자, 숫자를 표현하는 방법
        
    2. **명령어**
        
        : 컴퓨터를 실질적으로 움직이는 정보
        
        : 데이터는 명령어를 위한 일종의 재료
        
2. 컴퓨터의 네 가지 핵심 부품
    1. **CPU**
        1. **ALU** : 계산기
        2. **레지스터** : CPU 내부의 작은 저장장치
        3. **제어 장치** : 제어 신호를 내보내고, 명령어를 해석하는 장치
        
        : 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 부품
        
    2. **메모리(주기억 장치)**
        
        : **RAM**, **ROM**
        
        : 프로세스의 명령어와 데이터를 저장하는 부품
        
        : 프로그램이 실행되기 위해서는 메모리에 저장되어 있어야 한다
        
        : 메모리는 실행되는 프로그램의 명령어와 데이터를 저장한다
        
        : 메모리에 저장된 값의 위치는 주소로 알 수 있다
        
    3. **보조 기억 장치**
        
        : HDD, SSD
        
        : 전원이 꺼져도 보관될 프로그램을 저장하는 부품
        
    4. **입출력 장치**
        
        : 키보드, 마우스, 프린터
        
        : 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 부품
        
3. **메인보드**
    
    : 메인보드에 연결된 부품은 버스를 통해 정보를 주고 받음
    
    : 버스는 컴퓨터의 부품끼리 정보를 주고받는 일종의 통로
    
    : 다양한 종류의 버스가 있음
    
    : 컴퓨터의 핵심 부품을 연결하는 버스는 시스템 버스
    
4. **시스템 버스**
    1. **주소 버스** : 주소를 주고받는 통로
    2. **데이터 버스** : 명령어와 데이터를 주고받는 통로
    3. **제어 버스** : 제어 신호를 주고받는 통로
</aside>

### 3강 - 컴퓨터의 4가지 핵심 부품 직접 보기

### 4강 - 0과 1로 숫자로 표현하는 방법

<aside>
📖 **0과 1로 숫자로 표현하는 방법**

1. 정보 단위
    1. **bit**(비트) : 0과 1을 표현하는 가장 작은 정보 단위
        1. 1byte = 8bit
        2. 1kB = 1000byte
        3. 1MB = 1000kB
        4. 1GB = 1000MB
        5. 1TB = 1000GB
    2. **word** : CPU가 한 번에 처리할 수 있는 정보의 크기 단위
        1. half word : 워드의 절반 크기
        2. full word : 워드 크기
        3. double word : 워드의 두 배 크기
2. 이진법 (**binary**)
    1. 십진법 (**decimal**)
    2. 2의 보수 : 어떤 수를 그보다 큰 2의 n제곱에서 뺀 값
        
        ⇒ 모든 0과 1을 뒤집고 1을 더한 값
        
</aside>

### 5강 - 0과 1로 문자를 표현하는 방법

<aside>
📖 **0과 1로 문자를 표현하는 방법**

1. 문자 집합 (character set) : 컴퓨터가 이해할 수 있는 문자의 모음
2. 인코딩 (**encoding**) : 코드화하는 과정
3. 디코딩 (**decoding**) : 코드를 해석하는 과정
4. **아스키 코드** : 7bit로 하나의 문자를 표현, 나머지 1bit는 parity bit로 사용
5. 한글 인코딩
    1. 완성형 인코딩 : 초성, 중성, 종성으로 이루어진 단어 하나를 저장
    2. 조합형 인코딩 : 초성, 중성, 종성을 따로 저장
6. EUC-KR : KS X 1001 KS X 1003 문자 집합 기반의 한글 인코딩 방식, 완성형 인코딩
7. **유니코드** : 한글, 영어, 화살표와 같은 특수 문자, 이모티콘까지 표현 가능
8. **utf-8** 인코딩 : UTF == 유니코드 인코딩 방식, 가변 길이 인코딩
</aside>

### 6강 - 소스 코드와 명령어

<aside>
📖 **소스 코드와 명령어**

**고급 언어** : C, C++, JAVA, PYTHON 등 개발자가 읽고 쓰기 편하게 만들어진 언어

**저급 언어** : 컴퓨터 내부에서 실행되는 명령어

**컴파일 언어** : 소스 코드 → 컴파일러 → 목적 코드

**인터프리터 언어** : 소스 코드를 한 줄씩 실행

</aside>

### 7강 - 명령어의 구조와 주소 지정 방식

<aside>
📖 **명령어의 구조와 주소 지정 방식**

1. 명령어 구조
    1. 수행할 연산 + 연산에 사용될 데이터 or 연산에 사용될 데이터가 저장된 위치
    2. **op code** : 연산
        1. 데이터 전송
            1. move, store, load, push, pop
        2. 산술/논리 연산
            1. add, subtract, multiply, divide
            2. increment, decrement
            3. and, or
            4. compare
        3. 제어 흐름 변경
            1. jump, conditional jump, halt, call, return
        4. 입출력 제어
            1. read, writem start io, test io
    3. **operand** : 연산에 사용될 데이터
        1. **0-주소 명령어** : 오퍼랜드가 없음
        2. **1-주소 명령어** : 오퍼랜드가 한개
        3. **2-주소 명령어** : 오퍼랜드가 두개
        4. **3-주소 명령어** : 오퍼랜드가 세개
    4. 명령어 주소 지정 방식
        1. 유효 주소 (effective adress) : 연산에 사용할 데이터가 저장된 위치
        2. **즉시 주소 지정 방식** : 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
        3. **직접 주소 지정 방식** : 오퍼랜드 필드에 유효 주소 직접적으로 명시
        4. **간접 주소 지정 방식** : 오퍼랜드 필드에 유효 주소의 주소를 명시
        5. **레지스터 주소 지정 방식** : 연산에 사용할 데이터가 저장된 레지스터 명시
</aside>

### 8강 - C언어의 컴파일 과정

<aside>
📖 **C언어의 컴파일 과정**

1. **전처리기(preprocessor)**
    1. 본격적으로 컴파일하기 전에 처리할 작업들
    2. 외부에 선언되 다양한 소스 코드, 라이브러리 포함
    3. 프로그래밍의 편의를 위해 작성된 매크로 변환
    4. 컴파일할 영역 명시
2. **컴파일러(compiler)**
    1. 전처리가 완료되어도 여전히 소스 코드
    2. 전처리 완료된 소스 코드를 저급 언어(어셈블리어)로 변환
3. **어셈블러(assembler)**
    1. 어셈블리어를 기계어로 변환
    2. 목적 코드(object file)를 포함하는 목적 파일이 됨
4. **링커(linker)**
</aside>

### 9강 - CPU의 내부 구성 : ALU와 제어장치

<aside>
📖 **ALU와 제어장치**

1. **ALU**
    1. 계산을 하기 위해서는 피연산자와 수행할 연산이 필요
2. **제어장치**
    1. clock : 컴퓨터의 모든 부품을 일사불란하게 움질일 수 있게 하는 시간 단위
</aside>

### 10강 - CPU의 내부 구성 : 레지스터

<aside>
📖 **레지스터**

1. **레지스터** : CPU 내부의 작은 임시 저장 장치
    1. 프로그램 속 명령어 & 데이터는 실행 전후로 레지스터에 저장
2. **PC** (program counter) : 다음 실행할 명령어의 주소를 저장
3. **명령어 레지스터** : 해석할 명령어 (방금 메모리에서 읽어 들인 명령어)
4. **MAR** (memory address register) : 메모리의 주소를 저장
5. **MBR** ( memory buffer register) : 메모리와 주고받을 값(데이터, 명령어)
6. **플래그 레지스터** : 연산 결과 또는 CPU 상태에 대한 부가적인 정보
7. **범용 레지스터** : 다양하고 일반적인 상황에서 자유롭게 사용
8. **스택 포인터** : 스택 주소 지정 방식에 사용, 스택의 꼭대기를 가리키는 레지스터
9. **베이스 레지스터** : 상대 주소 지정 방식에 사용, 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소 얻기
    1. 베이스 레지스터 주소 지정 방식 : 베이스 레지스터가 기준이 되는 값
</aside>

### 11강 - 명령어 사이클과 인터럽트

<aside>
📖 **명령어 사이클과 인터럽트**

1. **명령어 사이클**: 프로그램 속 명령어들이 반복되며 실행되는 주기
    1. **인출 사이클** : 메모리에 저장된 값을 CPU로 가져옴
    2. **실행 사이클** : CPU로 가져온 데이터를 실행
    3. **간접 사이클** : 메모리 접근이 더 필요한 경우, 실행
2. **인터럽트** : 우선 순위가 가장 높은, CPU가 먼저 처리해야 할 다른 작업이 생겼을 때 발생
    1. **동기 인터럽트** : CPU가 예기치 못한 상황을 접했을 때 발생
    2. **비동기(하드웨어) 인터럽트** : 주로 입출력 장치에서 발생
        1. 입출력 장치, CPU에게 인터럽트 요청 신호
        2. CPU, 실행 사이클 이후 명령어 인출 전 인터럽트 여부 확인
        3. CPU, 인터럽트 요청 확인, 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
        4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업 백업
        5. CPU는 인터럽트 벡터를 참조해 인터럽트 서비스 루틴 실행
        6. 인터럽트 서비스 루틴 실행 종료 후 백업해 둔 작업 복구 및 실행 재개
</aside>

### 12강 - 빠른 CPU를 위한 설계 기법

<aside>
📖 **빠른 CPU를 위한 설계 기법**

1. **클럭 속도** : Hz 단위
2. **Hz** : 1초에 클럭이 반복되는 횟수
3. **코어** : 명령어를 실행하는 부품
4. **스레드** : 실행 흐름의 단위
    1. 하드웨어적 스레드 : 하나의 코어가 동시에 처리하는 명령어 단위
    2. 소프트웨어적 스레드 : 하나의 프로그램에서 독립적으로 실행되는 단위
</aside>

### 13강 - 명령어 병렬 처리 기법

<aside>
📖 **명령어 병렬 처리 기법**

1. **명령어 파이프라인**
    1. 명령어 **인출**(Instruction Fetch)
    2. 명령어 **해석**(Instruction Decode)
    3. 명령어 **실행**(Execute Instruction)
    4. 결과 **저장**(Write Back)
2. **슈퍼스칼라** : CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조
3. **비순차석 명령어 처리** : 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 명령어 병렬 처리 기법
</aside>

### 14강 - 명령어 집합 구조, CISC와 RISC

<aside>
📖 **명령어 집합 구조, CISC와 RISC**

1. **명령어 집합** : CPU가 이해할 수 있는 명령어들의 모음
2. **CISC**(Complex Instruction Set Computer) : 복잡한 명령어 집합을 활용하는 컴퓨터
    1. 명령어의 형태와 크기가 다양한 가변 길이 명령어 활용
3. **RISC**(Reduced Instruction Set Computer)
</aside>

### 15강 - RAM의 특성과 종류

<aside>
📖 **RAM의 특성과 종류**

1. RAM의 특징 : **휘발성 저장 장치**
2. RAM의 용량과 성능 : **많은 프로그램들을 동시에 실행하는 데에 유리**
3. RAM의 종류
    1. **DRAM**(Dynamic RAM) : 저장된 데이터가 동적으로 사라지는 RAM
    2. **SRAM**(Static RAM) : 저장된 데이터가 정적인(사라지지 않는) RAM
    3. SDRAM(Synchronous DRAM) : 클럭 신호와 동기화된 DRAM
    4. DDR SDRAM(Double Data Rate SDRAM) : 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
</aside>

### 16강 - 메모리의 주소 공간 : 물리 주소와 논리 주소

<aside>
📖 **물리 주소와 논리 주소**

1. 물리 주소 : 메모리 입장에서 바라본 주소
2. 논리 주소 : CPU와 실행 중인 프로그램 입장에서 바라본 주소
3. 물리 주소와 논리 주소의 변환
    1. MMU(메모리 관리 장치)에 의해 변환
    2. 논리 주소와 베이스 레지스터 값을 더하여 논리 주소를 물리 주소로 변환
</aside>

### 17강 - 캐시 메모리

<aside>
📖 **캐시 메모리**

1. **저장 장치 계층 구조**
    1. CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다
    2. 속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸다
2. **캐시 메모리** : CPU와 메모리 사이에 위치한, 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치
    1. CPU의 연산 속도와 메모리 접근 속도의 차이를 조금이나마 줄이기 위해 탄생
    2. **L1 - L2 - L3 캐시** : CPU가 자주 사용할 법한 내용을 예측하여 저장
    3. **캐시 히트** : CPU가 캐시 메모리에 저장된 값을 활용할 경우
    4. **캐시 미스** : CPU가 메모리에 접근해야 하는 경우
    5. **캐시 적중률** : 캐시 히트 횟수 / (캐시 히드 횟수 + 캐시 미스 횟수)
3. **참조 지역성**의 원리
    1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다
    2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다(공간 지역성)
</aside>

### 18강 - 다양한 보조기억장치

<aside>
📖 **다양한 보조기억장치**

1. **하드디스크** : 자기적인 방식으로 데이터 저장
    1. 트랙과 섹처 단위로 데이터 저장
    2. **실린더** : 여러 겹의 플래터 상에서 같은 트랙이 위치 한 곳을 모아 연결한 논리적 단위
    3. 하드 디스크가 저장된 데이터에 접근하는 시간
        1. **탐색 시간**(seek time) : 접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간
        2. **회전 지연**(rotational latency) : 헤드가 있는 곳으로 플래터를 회전시키는 시간
        3. **전송 시간**(transfer time)
2. **플래시 메모리** : 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치
    1. **SLC** : 한 셀에 1bit를 저장할 수 있는 플래시 메모리
    2. **MLC** : 한 셀에 2bit를 저장할 수 있는 플래시 메모리
    3. **TLC** : 한 셀에 3bit를 저장할 수 있는 플래시 메모리
    4. **QLC** : 한 셀에 4bit를 저장할 수 있는 플래시 메모리
</aside>

### 19강 - RAID의 정의와 종류

<aside>
📖 **RAID의 정의와 종류**

1. **RAID** (Redundant Array of Independent Disks)
    1. 하드 디스크와 SSD로 사용하는 기술
    2. 데이터의 안정성 혹은 높은 성능을 위해 여러 물리적 보조 기억 장치를 마치 하나의 논리적 보조 기억 장치처럼 사용하는 기술
    3. RAID 0 : 데이터를 단순히 나누어 저장하는 구성 방식
    4. RAID 1 : 미러링, 복사본을 만드는 방식
    5. RAID 4 : 완전한 복사본을 만드는 대신 오류를 검출하고 복구하기 위한 정보를 저장
    6. RAID 5 : 패리티 정보를 분산하여 저장하는 방식
    7. RAID 6 : 두 종류의 패리티(오류를 검출하고 복구할 수 있는 수단)
</aside>

### 20강 - 장치 컨트롤러와 장치 드라이버

<aside>
📖 **장치 컨트롤러와 장치 드라이버**

1. **장치 컨트롤러** : 입출력장치를 컴퓨터와 연결하기 위한 도구
    1. 장치 컨트롤러의 역할
        1. CPU와 입출력 장치 간의 통신 중계
        2. 오류 검출
        3. 데이터 버퍼링
    2. 장치 컨트롤러의 구조
        1. 데이터 레지스터 : CPU와 입출력 장치 사이에 주고 받을 데이터가 담기는 레지스터
        2. 상태 레지스터 : 상태 정보를 저장
        3. 제어 레지스터 : 입출력 장치가 수행할 내용에 대한 제어 정보
2. **장치 드라이버** : 장치 컨트롤러의 동작을 감지하고 제어하는 프로그램
</aside>

### 21강 - 다양한 입출력 방법

<aside>
📖 **다양한 입출력 방법**

1. 프로그램 입출력 : 프로그램 속 명령어로 입출력 장치를 제어하는 방법
    1. 입출력 명령어로써 장치 컨트롤러와 상호 작용
    2. 메모리 맵 입출력 : 메모리에 접근하기 위한 주소 공간과 입출력 장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법
    3. 고립형 입출력 : 메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하는 방법
2. 인터럽트 기반 입출력 : 하드웨어 인터럽트는 장치 컨트롤러에 의해 발생
    1. PIC(Programmable Interrupt Controller) : 여러 장치 컨트롤러에 연결되어 장치 컨트롤러의 하드웨어 인터럽트의 우선 순위를 판단한 뒤 CPU에게 지금 처리해야 하는 인터럽트가 무엇인지 판단하는 하드웨어
3. DMA 입출력
    1. DMA (Direct Memory Access) : CPU를 거치지 않고 입출력 장치가 메모리에 직접적으로 접근하는 기능
</aside>