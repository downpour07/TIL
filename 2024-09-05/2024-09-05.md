### 23강 - 운영체제를 알아야 하는 이유

<aside>
📖 **운영체제를 알아야 하는 이유**

1. **자원**(시스템 자원) : 프로그램 실행에 있어 마땅히 필요한 요소
2. **운영체제** : 실행할 프로그램에 필요한 자원을 할당하고 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램
    1. 커널 영역에 적재되는 프로그램
</aside>

### 24강 - 운영체제의 큰 그림

<aside>
📖 **운영체제의 큰 그림**

1. **커널(kernel)** : 운영체제의 핵심 서비스를 담당하는 부분
2. 이중 모드 : CPU가 명령어를 실행하는 모드를 크게 사용자 모드와 커널 모드로 구분하는 방식
    1. **사용자 모드**
        1. 운영체제 서비스를 제공받을 수 없는 실행 모드
        2. 커널 영역의 코드를 실행할 수 없는 실행 모드
        3. 자원 접근 불가
    2. **커널 모드**
        1. 운영체제의 서비스를 제공받을 수 있는 실행 모드
        2. 자원 접근을 비롯한 모든 명령어 실행 가능
    3. **시스템 호출** : 운영체제 서비스를 제공받기 위해 커널 모드로 전환하는 방법
        1. 커널 모드로 전환하여 실행하기 위해 호출
        2. 일종의 소프트웨어 인터럽트
3. 운영체제의 핵심 서비스
    1. **프로세스 관리**
        1. 프로세스 : 현재 실행 중인 프로그램
        2. 수많은 프로세스들이 동시에 실행
    2. **자원 접근 및 할당**
        1. CPU (CPU 스케줄링 : 어떤 프로세스를 먼저, 얼마나 오래 실행할지)
        2. 메모리 (페이징, 스와핑)
        3. 입출력 장치
    3. **파일 시스템 관리**
        1. 관련된 정보를 파일이라는 단위로 저장 장치에 보관
        2. 파일들을 묶어 폴더(디렉터리) 단위로 저장 장치에 보관
</aside>

### 25강 - 시스템 호출(system call) 직접 관찰하기

### 26강 - 프로세스 개요

<aside>
📖 **프로세스 개요**

1. **포그라운드** 프로세스(foreground process) : 사용자가 볼 수 있는 공간에서 실행되는 프로세스
2. **백그라운드** 프로세스(background process) : 사용자가 볼 수 없는 공간에서 실행되는 프로세스
    1. **데몬**(daemon)
3. **프로세스 제어 블록**(Process Control Block)
    1. 프로세스들은 돌아가며 한정된 시간만큼 CPU 이용
    2. **PCB** 정보
        1. **프로세스 ID** (=PID) : 특정 프로세스를 식별하기 위해 부여하는 고유 번호
        2. **레지스터 값** : PC, STACK POINTER
        3. **프로세스 상태** : 준비, 실행, 대기
        4. **CPU 스케줄링 정보**
        5. **메모리 정보** : 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
        6. **사용한 파일과 입출력 장치 정보** : 할당된 입출력 장치, 사용 중이 파일 정보
4. **문맥 교환(context switch)** : 기존의 실행 중인 프로세스 문맥을 백업하고 새로운 프로세스 실행을 위해 문맥을 복구하는 과정
5. 프로세스의 메모리 영역
    1. **코드** 영역 : 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
    2. **데이터** 영역 : 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터 저장
    3. **힙** 영역 : 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장공간
    4. **스택** 영역 : 데이터가 일시적으로 저장되는 공간
</aside>

### 27강 - 프로세스 상태와 계층 구조

<aside>
📖 **프로세스 상태와 계층 구조**

1. **프로세스 상태**
    1. **생성** : 메모리에 적재되어 PCB를 할당 받은 상태
    2. **준비** : 자신의 차례가 아니기에 CPU 할당을 기다리는 상태
    3. **실행** : CPU를 할당 받아 실행 중인 상태
    4. **대기** : 프로세스가 실행 도중 입출력 장치를 사용하는 경우
    5. **종료** : 프로세스가 종료된 상태
2. **프로세스 계층 구조**
    1. **부모 프로세스** : 새 프로세스를 생성한 프로세스
    2. **자식 프로세스** : 부모 프로세스에 의해 생성된 프로세스
    3. 부모 프로세스와 자식 프로세스는 별개의 프로세스이므로 각기 다른 PID를 가짐
3. 프로세스 생성 기법
    1. **fork()** : 자신의 복사본을 자식 프로세스로 생성하는 시스템 콜
    2. **exec()** : 자신의 메모리 공간을 다른 프로그램으로 교체하는 시스템 콜
</aside>

### 28강 - 스레드

<aside>
📖 **스레드**

1. 단일 스레드 프로세스 : 실행 흐름이 하나인 프로세스
2. 멀티 스레드 프로세스 : 실행 흐름이 여러 개인 프로세스
3. 스레드의 구성 요소
    1. 스레드 ID, 레지스터 값, 스택 등
4. 프로세스끼리는 자원을 공유하지 않는다
    1. 프로세스 간에도 자원을 주고받을 수 있다 : 프로세스 간 통신(IPC)
    2. 파일을 통한 프로세스 간 통신, 공유 메모리를 통한 프로세스 간 통신
5. 스레드는 프로세스의 자원을 공유한다
</aside>

### 29강 - 파이썬 코드로 프로세스 확인하기

### 30강 - 파이썬 코드로 스레드 확인하기

### 31강 - CPU 스케줄링 개요

<aside>
📖 **CPU 스케줄링 개요**

1. **CPU 스케줄링** : 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것
2. **프로세스 우선 순위 (priority)**
    1. 입출력 작업이 많은 프로세스(=입출력 집중 프로세스)의 우선순위는 CPU 작업이 많은 프로세스(=CPU 집중 프로세스)의 우선순위가 높다
3. **스케줄링 큐**
    1. 준비 큐 : CPU를 이용하기 위해 기다림
    2. 대기 큐 : 입출력 장치를 이용하기 위해 기다림
4. **선정형 스케줄링**(preemptive schduling)
5. **비선점형 스케줄링**(non-preemptive schduling)
</aside>

### 32강 - CPU 스케줄링 알고리즘

<aside>
📖 **CPU 스케줄링 알고리즘**

1. **선입 선처리 스케줄링(FCFS)**
    1. First Come FIrst Served 스케줄링
    2. 단순히 준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링
2. **최단 작업 우선 스케줄링(SJF)**
    1. Shortest Job First 스케줄링
    2. CPU 사용 시간이 긴 프로세스는 나중에, CPU 사용 시간이 짧은 프로세스는 먼저 실행
3. **라운드 로빈 스케줄링(RR)**
    1. Round Robin 스케줄링
    2. 선입 선처리 스케줄링 + 타임 슬라이스
    3. 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
4. **최소 잔여 시간 우선 스케줄링(SRT)**
    1. Shortest Remaining Time 스케줄링
    2. 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
    3. 정해진 시간만큼 CPU를 이용하되, 다음으로 CPU를 사용할 프로세스로는 남은 작업 시간이 가장 적은 프로세스 선택
5. **우선 순위 스케줄링**
    1. 프로세스들에 우선순위를 부여하고, 우선순위가 높은 프로세스부터 실행
6. **다단계 큐 스케줄링**
    1. Multilevel queue 스케줄링
7. **다단계 피드백 큐 스케줄링**
    1. Multilevel feedback queue 스케줄링
</aside>

### 33강 - 프로세스 동기화란?

<aside>
📖 **프로세스 동기화**

1. **동기화**
    1. 공동의 목적을 위해 동시에 수행되는 프로세스
2. **프로세스 동기화**
    1. 프로세스들의 수행 시기를 맞추는 것
    2. 실행 순서 제어 : 프로세스를 올바른 순서대로 실행하기
        1. Writer : Book.txt 파일에 값을 저장하는 프로세스
        2. Reader : Book.txt 파일에 저장된 값을 읽어들이는 프로세스
    3. 상호 배제 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기
3. producer : 물건을 계속해서 생산하는 생산자
4. consumer : 물건을 계속해서 소비하는 소비자
5. **공유 자원** : 여러 프로세스 혹은 스레드가 공유하는 자원
6. **임계 구역** : 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역
7. 레이스 컨디션(race condition) : 임계 구역에 동시에 접근하면 자원의 일관성이 깨질 수 있다
8. **상호 배제** : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 들어올 수 없다
9. 진행 : 임계 구역에 어떤 프로세스도 진입하지 않았다면 진입하고자 하는 프로세스는 들어갈 수 있어야 한다
10. **유한 대기** : 한 프로세스가 임계 구역에 진입하고 싶다면 언젠가는 임계 구역에 들어올 수 있어야 한다
    1. 임계 구역에 들어오기 위해 무한정 대기해서는 안 된다)
</aside>

### 34강 - 프로세스 동기화 기법

<aside>
📖 **프로세스 동기화 기법**

1. **뮤텍스 락** : 상호 배제를 위한 동기화 도구(자물쇠 역할)
    1. 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 lock
    2. 임계 구역을 잠그는 역할 : acquire 함수
        1. 프로세스가 임계 구역에 진입하기 전에 호출
        2. 임계 구역이 잠겨있다면 ⇒ 임계 구역이 열릴 때까지(lock이 false가 될 때까지) 임계 구역을 반복적으로 확인
        3. 임계 구역이 열려 있다면 ⇒ 임계 구역을 잠그기(lock을 true로 바꾸기)
    3. 임계 구역의 잠금을 해제하는 역할 : release 함수
        1. 임계 구역에서의 작업이 끝나고 호출
        2. 현재 잠긴 임계 구역을 열기(lock을 false로 바꾸기)
2. **세마포** : 좀 더 일반화된 방식의 동기화 도구
    1. 공유 자원이 여러 개 있는 경우에도 적용 가능
    2. 임계 구역 앞에서 멈춤 신호를 받으면 잠시 기다리기
    3. 임계 구역 앞에서 가도 좋다는 신호를 받으면 임계 구역 진입
3. **모니터** : 사용자(개발자)가 다루기에 편한 동기화 도구
    1. 상호 배제를 위한 동기화
        1. 인터페이스를 위한 큐
        2. 공유 자원에 접근하고자 하는 프로세스를 (인터페이스를 위한) 큐에 삽입
        3. 큐에 삽입된 순서대로 (한 번에 하나의 프로세스만) 공유 자원 이용
    2. 실행 순서 제어를 위한 동기화
        1. 조건 변수 이용
</aside>

### 35강 - 교착 상태

<aside>
📖 **교착 상태**

1. **교착 상태** : 둘 이상의 프로세스들이 다른 프로세스가 차지하고 있는 자원을 서로 무한정 기다리고 있어 프로세스의 진행이 중단된 상태
2. 자원 할당 그래프
    1. 첫째, 프로세스는 원으로, 자원의 종류는 사각형으로 표현
    2. 둘째, 사용할 수 있는 자원의 개수는 자원 사각형 내에 점으로 표현
    3. 셋째, 프로세스가 어떤 자원을 할당 받아 사용 중이라면 자원에서 프로세스를 향해 화살표를 표시
    4. 넷째, 프로세스가 어떤 자원을 기다리고 있다면 프로세스에서 자원으로 화살표를 표시
3. 교착 상태 발생 조건
    1. 상호 배제 : 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상태
    2. 점유와 대기 : 자원을 할당 받은 상태에서 다른 자원을 할당 받기를 기다리는 상태
    3. 비선점 : 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못하는 상태
    4. 원형 대기 : 프로세스들이 원의 형태로 자원을 대기하는 상태
</aside>

### 36강 - 교착 상태 해결 방법

<aside>
📖 **교착 상태 해결 방법**

1. **교착 상태 예방** : 상호 배제, 점유와 대기, 비선점, 원형 대기 중 하나를 없애버리기
    1. 상호 배제 ⇒ 모든 자원을 공유 가능하게 만든다?
    2. 점유와 대기 ⇒ 특정 프로세스에 자원을 모두 할당하거나, 아예 할당하지 않는 방식으로 배분
    3. 비선점 ⇒ 선점이 가능한 자원(CPU)에 한해 효과적
    4. 원형 대기 조건 ⇒ 자원에 번호를 붙이고 오름차순으로 할당하면 원형 대기는 발생하지 않음
2. **교착 상태 회피**
    1. 교착 상태를 무분별한 자원 할당으로 인해 발생했다고 간주
    2. 교착 상태가 발생하지 않을 만큼 조심 조심 할당하기
    3. 배분할 수 있는 자원의 양을 고려하여 교착 상태가 발생하지 않을 만큼만 자원 배분
    4. 안전 순서열 : 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서
    5. 안전 상태 : 교착 상태 없이 모든 프로세스가 자원을 할당 받고 종료될 수 있는 상태
    6. 불안전 상태 : 교착 상태가 발생할 수도 있는 상태
3. **교착 상태 검출 후 회복**
    1. 교착 상태의 발생을 인정하고 사후에 조치하는 방식
    2. 프로세스가 자원을 요구하면 일단 할당, 교착 상태가 검출되면 회복
    3. 선점을 통한 회복 : 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식
    4. 프로세스 강제 종료를 통한 회복
        1. 교착 상태에 놓인 프로세스 모두 강제 종료
        2. 교착 상태가 해결될 때까지 한 프로세스씩 강제 종료
4. **교차 상태 무시** : 타조 알고리즘
</aside>

### 37강 - 연속 메모리 할당

<aside>
📖 **연속 메모리 할당**

1. **연속 메모리 할당** : 프로세스에 연속적인 메모리 공간을 할당
2. **스와핑** : 현재 사용되지 않는 프로세스들을 보조기억장치의 일부 영역으로 쫓아내고 그렇게 생긴 빈 공간에 새 프로세스 적재
    1. 프로세스들이 요구하는 메모리 공간 크기 > 실제 메모리 크기
3. 메모리 할당 : 프로세스는 메모리의 빈 공간에 할당되어야 한다 → 빈 공간이 여러 개 있다면?
    1. 최초 적합 : 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
        1. 검색 최소화, 빠른 할당
    2. 최적 적합 : 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 작은 공간에 할당
    3. 최악 적합 : 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 큰 공간에 할당
4. 외부 단편화 : 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상
    1. 메모리 압축(compaction) : 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식
    2. 가상 메모리 기법, 페이징
</aside>

### 38강 - 페이징을 통한 가상 메모리 관**리**

<aside>
📖

**페이징을 통한 가상 메모리 관리**

1. **페이징**(paging)
    1. 프로세스의 논리 주소 공간을 페이지(page)라는 일정 단위로 자르고
    2. 메모리의 물리 주소 공간을 프레임(frame)이라는 페이지와 동일한 일정한 단위로 자른 뒤
    3. 페이지를 프레임에 할당하는 가상 메모리 관리 기법
2. 페이징에서의 스와핑
    1. 프로세스 단위의 swap in, swap out이 아닌 페이지 단위의 swap in(page in), swap out(page out)
    2. 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 swap out
    3. 실행에 필요한 페이지들은 메모리로 swap in
3. **페이지 테이블**
    1. (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도
    2. (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 하는 방법
    3. 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표
    4. 프로세스마다 페이지 테이블이 존재
4. 내부 단편화 : 하나의 페이지 크기보다 작은 크기로 발생
5. PTBR
    1. 프로세스마다 페이지 테이블이 있고
    2. 각 페이지 테이블은 CPU 내의 프로세스 테이블 베이스 레지스터(PTBR)가 가리킨다
6. TLB : CPU 곁에 페이지 테이블의 캐시 메모리
    1. TLB 히트 : 메모리 접근이 한 번 일어날 때
    2. TLB 미스 : 메모리 접근이 두 번 일어날 때
7. 페이징에서의 주소 변환
    1. 페이징 시스템에서의 논리 주소 : 페이지 번호 + 변위
    2. 페이징 시스템에서의 물리 주소 : 프레임 번호 + 변위
8. 페이지 테이블 엔트리 : 페이지 테이블의 각각의 행
9. 유효 비트 : 현재 해당 페이지에 접근 가능한지 여부
    1. 유효 비트가 0인 페이지에 접근하려고 하면 페이지 폴트(page fault)라는 인터럽트 발생
10. 보호 비트 : 페이지 보호 기능을 위해 존재하는 비트
11. 참조 비트 : CPU가 이 페이지에 접근한 적이 있는지 여부
12. 수정 비트(dirty bit) : CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부
    1. 수정된 페이지는 swap out될 때 보조기억장치에도 쓰기 작업을 거쳐야 한다
</aside>

### 39강 - 페이지 교체와 프레임 할당

<aside>
📖

**페이지 교체와 프레임 할당**

1. 요구 페이징 : 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법
2. 페이지 교체 알고리즘
    1. 요구 페이징 기법으로 페이지들을 적재하다보면 언젠간 메모리가 가득 차게 된다
    2. 당장 실행에 필요한 페이지를 적재하려면 적재된 페이지를 보조기억장치로 내보내야함
    3. 이때, 어떤 페이지를 내보낼까?
    4. 이를 결정하는 방법(알고리즘)이 페이지 교체 알고리즘
3. 좋은 페이지 교체 알고리즘이란?
    1. 페이지 폴트가 적은 알고리즘 ⇒ 페이지 폴트가 발생하면 보조기억장치에 접근해야 해서 성능 저하
4. **페이지 참조열(page reference string)**
    1. CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열
5. FIFO 페이지 교체 알고리즘
    1. 가장 단순한 방식
    2. 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식
    3. 프로그램 실행 초기에 잠깐 실행될 페이지 ← 내쫓아도 됨
    4. but 프로그램 실행 내내 실행될 페이지 ← 먼저 적재되었다고 내쫓으면 안됨
6. 2차 기회 페이지 교체 알고리즘
    1. 참조 비트 1 : CPU가 한 번 참조한 적이 있는 페이지 ← 참조 비트를 0으로 초기화 후 적재 시간을 현재 시간으로 재설정
    2. 참조 비트 0 : CPU가 참조한 적이 없는 페이지 ← 내쫓기
7. 최적 페이지 교체 알고리즘
    1. 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘
    2. CPU에 의해 참조되는 횟수를 고려
    3. 메모리에 오래 남아야할 페이지는 자주 사용될 페이지
    4. 메모리에 없어도 될 페이지는 오랫동안 사용되지 않을 페이지
8. LRU(Least-Recently-Used) 페이지 교체 알고리즘
    1. 가장 오래 사용되지 않은 페이지 교체
9. **스래싱** : 프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능(CPU 이용률)이 저해되는 문제
    1. 동시 실행되는 프로세스의 수를 늘린다고 CPU 이용률이 높아지는 것은 아님
    2. 각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고 프로세스들에게 적절한 프레임을 할당해주어야 한다
10. 균등 할당(equal allocation)
    1. 가장 단순한 할당 방식
    2. 모든 프로세스들에게 균등하게 프레임을 할당하는 방식
11. 비례 할당(proportional allocation)
    1. 프로세스의 크기에 비례하여 프레임 할당
12. 작업 집합 모델
    1. 프로세스가 실행하는 과정에서 배분할 프레임 결정
    2. 스레싱이 발생하는 이유는 빈번한 페이지 교체 때문
        
        ⇒ 그렇다면 CPU가 특정 시간 동안 주로 참조한 페이지 개수만큼만 프레임을 할당하면 된다
        
</aside>

### 40강 - 페이징의 이점과 계층적 페이징

<aside>
📖

**페이징의 이점과 계층적 페이징**

1. fork()
    1. 프로세스는 기본적으로 자원을 공유하지 않는다
    2. 부모 프로세스가 적재된 별도의 공간에 자식 프로세스가 통채로 복제되어 적재
    
    ⇒ 프로세스 생성 시간 지연, 메모리 낭비
    
2. 쓰기 시 복사
    1. 부모 프로세스와 동일한 자식 프로세스가 복제되어 생성되면
    2. 자식 프로세스는 부모 프로세스와 동일한 프레임을 가리킴
    3. 부모 프로세스/자식 프로세스 둘 중 하나가 페이지에 쓰기 작업 수행 시
    4. 해당 페이지는 별도의 공간으로 복제
    
    ⇒ 프로세스 생성 시간 절약, 메모리 절약
    
3. **계층적 페이징**
    1. 프로세스 테이블의 크기는 생각보다 작지 않다
    2. 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 큰 낭비
    3. 프로세스를 이루는 모든 페이지 테이블 엔트리를 항상 메모리에 유지하지 않을 방법
    4. 페이지 테이블을 페이징하여 여러 단계의 페이지를 두는 방식
    5. 모든 페이지 테이블을 항상 메모리에 적재할 필요가 없어짐
</aside>

### 41강 - 파일과 디렉터리

<aside>
📖

**파일과 디렉터리**

1. **파일**
    1. 보조기억장치에 저장된 관련 정보의 집합
    2. 의미있고 관련있는 정보를 모은 논리적 단위
    3. 파일을 이루는 정보
        1. 파일을 이루는 정보
        2. 파일을 실행하기 위한 정보
        3. 부가 정보(= 속성, 메타 데이터)
            1. 확장자
            2. 크기
            3. 보호
            4. 생성 날짜
            5. 수정 날짜
            6. 접근 날짜
            7. 생성자
            8. 소유자
            9. 위치
    4. 파일 연산을 위한 시스템 호출
        1. 파일 생성 : create
        2. 파일 삭제 : delete
        3. 파일 열기 : open
        4. 파일 닫기 : close
        5. 파일 읽기 : read
        6. 파일 쓰기 : write
2. **디렉터리(폴더)**
    1. 여러 계층으로 파일 및 폴더를 관리하는 트리 구조 디렉터리
    2. 최상위 디렉터리(루트 디렉터리)
3. **경로** : 디렉터리를 이용해 파일/디렉터리의 위치, 나아가 이름까지 특정 지을 수 있는 정보
    1. 절대 경로 : 루트 디렉터리로부터의 파일 위치까지 이르는 고유한 경로
    2. 상대 경로 : 현재 디렉터리로부터의 파일 위치까지 이르는 경로
4. 디렉터리 엔트리 : 해당 디렉터리에 담겨있는 대상과 관련된 정보가 담겨있음
</aside>

### 41강 - 파일 시스템

<aside>
📖

**파일 시스템**

1. **파티셔닝** : 저장 장치의 논리적인 영역을 구획하는 작업
2. **포매팅** : 파일 시스템을 설정, 어떤 방식으로 관리할지 결정, 새로운 데이터를 쓸 준비하는 작업
3. 파일 할당 방법
    1. 연속 할당 : 보조기억장치 내 연속적인 블록에 파일 할당
        1. 연속된 파일에 접근하기 위해 파일의 첫 번째 블록 주소와 블록 단위의 길이만 알면 된다
        2. 디렉터리 엔트리 : 파일 이름 & 첫 번째 블록 주소 & 블록 단위 길이 명시
    2. 불연속 할당
        1. 연결 할당
            1. 각 블록의 일부에 다음 블록의 주소를 저장하여 각 블록이 다음 블록을 가리키는 형태로 할당
            2. 파일을 이루는 데이터 블록을 연결 리스트로 관리
            3. 디렉터리 엔트리 : 파일 이름 & 첫 번째 블록 주소 & 블록 단위의 길이
        2. 색인 할당
            1. 파일의 모든 블록 주소를 색일 블록이라는 하나의 블록에 모아 관리하는 방식
            2. 파일 내 임의의 위치에 접근하기 용이
            3. 디렉터리 엔트리 : 파일 이름 & 색인 블록 주소
4. FAT 파일 시스템
    1. 연결 할당 기반 파일 시스템
    2. 연결 할당의 단점을 보완
    3. 각 블록에 포함된 다음 블록 주소를 한데 모아 테이블(FAT: File Allocation Table)로 관리
    4. FAT를 활용하는 파일 시스템
5. 유닉스 파일 시스템
    1. 색인 할당 기반 파일 시스템
    2. 색인 블록 == i-node
        1. 파일의 속성 정보와 15개의 블록 주소 저장 가능
</aside>